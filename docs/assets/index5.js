import{d as u,S as i,_ as p,c as o,a as t,f as s,o as a,h as m,t as S,b as y,e as r,w as k,r as d,A as C}from"./index.js";const E=u({name:"Destroy",data(){return{destroySingle:null,destroyMultiple:null}},mounted(){this.create()},methods:{create(){this.destroySingle=new i({select:this.$refs.destroySingle}),this.destroyMultiple=new i({select:this.$refs.destroyMultiple})},destroy(){this.destroySingle.destroy(),this.destroySingle=null,this.destroyMultiple.destroy(),this.destroyMultiple=null}}}),T={id:"destroy",class:"content"},K={class:"row"},j={ref:"destroySingle"},G={ref:"destroyMultiple",multiple:""};function A(l,e,c,v,g,h){return a(),o("div",T,[e[4]||(e[4]=t("h2",{class:"header"},"destroy",-1)),e[5]||(e[5]=t("p",null," The destroy method completely removes the SlimSelect instance and restores the original HTML select element to its native state. This is essential for cleanup operations, memory management, and scenarios where you need to revert to the original select element or recreate the SlimSelect instance with different configurations. ",-1)),e[6]||(e[6]=t("p",null," When called, this method removes all SlimSelect-generated DOM elements, event listeners, and internal state, leaving only the original select element. This is particularly useful in single-page applications, dynamic content scenarios, or when implementing component lifecycle management where SlimSelect instances need to be properly cleaned up to prevent memory leaks. ",-1)),t("div",K,[l.destroySingle?(a(),o("div",{key:1,class:"btn",onClick:e[1]||(e[1]=(...n)=>l.destroy&&l.destroy(...n))},"Destroy")):(a(),o("div",{key:0,class:"btn",onClick:e[0]||(e[0]=(...n)=>l.create&&l.create(...n))},"Create")),t("select",j,[...e[2]||(e[2]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),t("select",G,[...e[3]||(e[3]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512)]),e[7]||(e[7]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'
        })
        select.destroy()
      `),s(`
    `)],-1))])}const W=p(E,[["render",A]]),I=u({name:"EnableDisable",data(){return{setEnableSingle:null,setEnableMultiple:null}},mounted(){this.setEnableSingle=new i({select:this.$refs.setEnableSingle}),this.setEnableMultiple=new i({select:this.$refs.setEnableMultiple})},methods:{setEnable(){this.setEnableSingle.enable(),this.setEnableMultiple.enable()},setDisable(){this.setEnableSingle.disable(),this.setEnableMultiple.disable()}}}),N={id:"enableDisable",class:"content"},B={class:"row"},H={ref:"setEnableSingle",disabled:""},L={ref:"setEnableMultiple",multiple:"",disabled:""};function P(l,e,c,v,g,h){return a(),o("div",N,[e[4]||(e[4]=t("h2",{class:"header"},"enable / disable",-1)),e[5]||(e[5]=t("p",null," The enable and disable methods provide programmatic control over the SlimSelect instance's interactive state. These methods are essential for creating dynamic interfaces where dropdowns need to be temporarily unavailable based on user permissions, form validation, or other business logic conditions. ",-1)),e[6]||(e[6]=t("p",null," When disabled, the dropdown becomes non-interactive and visually indicates its disabled state. You can also set the disabled state directly on the original HTML select element, and SlimSelect will automatically detect and respect this state, ensuring consistency between the native element and the enhanced interface. ",-1)),t("div",B,[l.setEnableSingle&&l.setEnableSingle.settings.disabled?(a(),o("div",{key:0,class:"btn",onClick:e[0]||(e[0]=(...n)=>l.setEnable&&l.setEnable(...n))},"Enable")):(a(),o("div",{key:1,class:"btn",onClick:e[1]||(e[1]=(...n)=>l.setDisable&&l.setDisable(...n))},"Disable")),t("select",H,[...e[2]||(e[2]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),t("select",L,[...e[3]||(e[3]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512)]),e[7]||(e[7]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'
        })
        select.enable()
        // or
        select.disable()
      `),s(`
    `)],-1))])}const R=p(I,[["render",P]]),z=u({name:"GetData",data(){return{getDataOptions:null,getDataOptionsValue:[],getDataOptgroups:null,getDataOptgroupsValue:[]}},mounted(){this.getDataOptions=new i({select:this.$refs.getDataOptions}),this.getDataOptgroups=new i({select:this.$refs.getDataOptgroups})},methods:{getData(){this.getDataOptionsValue=this.getDataOptions.getData(),this.getDataOptgroupsValue=this.getDataOptgroups.getData()}}}),J={id:"getData",class:"content"},U={class:"row"},Y={ref:"getDataOptions"},q={key:0,class:"pad-t-m pad-b-m"},F={ref:"getDataOptgroups",multiple:""},Q={key:0,class:"pad-t-m pad-b-m"};function X(l,e,c,v,g,h){return a(),o("div",J,[e[5]||(e[5]=t("h2",{class:"header"},"getData",-1)),e[6]||(e[6]=t("p",null," The getData method retrieves the complete data structure currently loaded in the SlimSelect instance, including all options and optgroups. This is useful for debugging, data analysis, or when you need to access the full dataset for processing or manipulation. ",-1)),e[7]||(e[7]=t("p",null," This method returns the raw data objects with all their properties, allowing you to access not just the display values but also any additional data attached to each option, such as custom attributes, metadata, or configuration options that were set when the data was loaded. ",-1)),t("div",U,[t("div",{class:"btn",onClick:e[0]||(e[0]=(...n)=>l.getData&&l.getData(...n))},"Get Data"),t("div",null,[t("select",Y,[...e[1]||(e[1]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),l.getDataOptionsValue.length?(a(),o("div",q,[e[2]||(e[2]=t("b",null,"Option Data:",-1)),s(" "+S(l.getDataOptionsValue),1)])):m("",!0)]),t("div",null,[t("select",F,[...e[3]||(e[3]=[y('<optgroup label="Group 1"><option value="value1">Value 1</option><option value="value2">Value 2</option><option value="value3">Value 3</option></optgroup><optgroup label="Group 2"><option value="value4">Value 4</option><option value="value5">Value 5</option><option value="value6">Value 6</option></optgroup>',2)])],512),l.getDataOptgroupsValue.length?(a(),o("div",Q,[e[4]||(e[4]=t("b",null,"Optgroup Data:",-1)),s(" "+S(l.getDataOptgroupsValue),1)])):m("",!0)])]),e[8]||(e[8]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'
        })
        var data = select.getData() // Will return an array of options and optgroups
        console.log(data)
      `),s(`
    `)],-1))])}const Z=p(z,[["render",X]]),_=u({name:"GetSelected",data(){return{selectedSingle:null,selectedSingleValue:[],selectedMultiple:null,selectedMultipleValue:[],selectedKeepOrder:null,selectedKeepOrderValue:[]}},mounted(){this.selectedSingle=new i({select:this.$refs.selectedSingle}),this.selectedMultiple=new i({select:this.$refs.selectedMultiple}),this.selectedKeepOrder=new i({select:this.$refs.selectedKeepOrder,settings:{keepOrder:!0}}),this.selectedKeepOrder.setSelected(["value3","value1"])},methods:{getSelected(){this.selectedSingleValue=this.selectedSingle.getSelected(),this.selectedMultipleValue=this.selectedMultiple.getSelected(),this.selectedKeepOrderValue=this.selectedKeepOrder.getSelected()}}}),x={id:"getSelected",class:"content"},ee={class:"row"},te={ref:"selectedSingle"},le={key:0,class:"pad-t-m pad-b-m"},se={ref:"selectedMultiple",multiple:""},ne={key:0,class:"pad-t-m pad-b-m"},oe={ref:"selectedKeepOrder",multiple:""},ae={key:0,class:"pad-t-m pad-b-m"};function ie(l,e,c,v,g,h){return a(),o("div",x,[e[7]||(e[7]=y('<h2 class="header">getSelected</h2><p> The getSelected method retrieves the currently selected values from the SlimSelect instance, returning them as an array of strings. This is essential for form processing, data validation, and any scenario where you need to access the user&#39;s current selections programmatically. </p><p> Whether you&#39;re working with single-select or multi-select dropdowns, this method provides a consistent interface for accessing selected values, making it easy to integrate SlimSelect with form handling, API calls, or other application logic that depends on user selections. </p><div class="alert info"> Whether or not its a single or multiple select, getSelected will always return an array. </div><div class="alert"><p><strong>Multi-Select Order:</strong></p><ul><li><code>keepOrder: false</code> (default) → Returns in <strong>DOM order</strong> (how options appear in HTML) </li><li><code>keepOrder: true</code> → Returns in <strong>selection order</strong> (order you clicked them)</li></ul></div>',5)),t("div",ee,[t("div",{class:"btn",onClick:e[0]||(e[0]=(...n)=>l.getSelected&&l.getSelected(...n))},"Get Selected"),t("div",null,[t("select",te,[...e[1]||(e[1]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),l.selectedSingleValue.length?(a(),o("div",le,[e[2]||(e[2]=t("b",null,"Single Select Value:",-1)),s(" "+S(l.selectedSingleValue),1)])):m("",!0)]),t("div",null,[t("select",se,[...e[3]||(e[3]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2",selected:""},"Value 2",-1),t("option",{value:"value3",selected:""},"Value 3",-1)])],512),l.selectedMultipleValue.length?(a(),o("div",ne,[e[4]||(e[4]=t("b",null,"Multi Select Value:",-1)),s(" "+S(l.selectedMultipleValue),1)])):m("",!0)]),t("div",null,[t("select",oe,[...e[5]||(e[5]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),l.selectedKeepOrderValue.length?(a(),o("div",ae,[e[6]||(e[6]=t("b",null,"Keep Order Value:",-1)),s(" "+S(l.selectedKeepOrderValue),1)])):m("",!0)])]),e[8]||(e[8]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'

          // Optional - If you want to keep the order of the selected values
          // settings: { keepOrder: true }
        })
        var values = select.getSelected() // Will return an array of strings
        console.log(values)
      `),s(`
    `)],-1))])}const re=p(_,[["render",ie]]),de=u({name:"OpenClose",data(){return{openCloseSingle:null,openCloseMultiple:null}},mounted(){this.openCloseSingle=new i({select:this.$refs.openCloseSingle}),this.openCloseMultiple=new i({select:this.$refs.openCloseMultiple})},methods:{toggleOpenClose(){this.openCloseSingle.settings.isOpen?(this.openCloseSingle.close(),this.openCloseMultiple.close()):(this.openCloseSingle.open(),this.openCloseMultiple.open())}}}),ue={id:"openClose",class:"content"},pe={class:"row"},ce={ref:"openCloseSingle"},ve={ref:"openCloseMultiple",multiple:""};function ge(l,e,c,v,g,h){return a(),o("div",ue,[e[3]||(e[3]=t("h2",{class:"header"},"open / close",-1)),e[4]||(e[4]=t("p",null," The open and close methods provide programmatic control over the dropdown's visibility state. These methods are essential for creating custom interactions, implementing keyboard navigation, or building complex user interfaces where you need to control when the dropdown appears or disappears. ",-1)),e[5]||(e[5]=t("p",null," The open method displays the dropdown options and search interface, while the close method hides them. This is particularly useful for implementing custom triggers, creating keyboard shortcuts, or integrating SlimSelect with other UI components that need to control the dropdown's state programmatically. ",-1)),t("div",pe,[t("div",{class:"btn",onClick:e[0]||(e[0]=n=>l.toggleOpenClose())},"Open/Close"),t("select",ce,[...e[1]||(e[1]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),t("select",ve,[...e[2]||(e[2]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512)]),e[6]||(e[6]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement',
        })
        select.open()
        // or
        select.close()
      `),s(`
    `)],-1))])}const he=p(de,[["render",ge]]),me=u({name:"Search",data(){return{searchSingle:null,searchMultiple:null}},mounted(){this.searchSingle=new i({select:this.$refs.searchSingle}),this.searchMultiple=new i({select:this.$refs.searchMultiple})},methods:{setSearch(){this.searchSingle.open(),this.searchSingle.search("value 2"),this.searchMultiple.open(),this.searchMultiple.search("value 2")}}}),Se={id:"search",class:"content"},fe={class:"row"},be={ref:"searchSingle"},ye={ref:"searchMultiple",multiple:""};function $e(l,e,c,v,g,h){return a(),o("div",Se,[e[3]||(e[3]=t("h2",{class:"header"},"search",-1)),e[4]||(e[4]=t("p",null," The search method allows you to programmatically set the search input value and filter the dropdown options accordingly. This is particularly useful for implementing custom search functionality, pre-filtering options based on external conditions, or creating advanced search interfaces that go beyond the default search behavior. ",-1)),e[5]||(e[5]=t("p",null," When called, this method updates the search input field and immediately applies the search filter to the available options, showing only those that match the search criteria. This is essential for creating responsive search experiences where the search term can be set programmatically based on user interactions or external data. ",-1)),t("div",fe,[t("div",{class:"btn",onClick:e[0]||(e[0]=n=>l.setSearch())},"Set Search"),t("select",be,[...e[1]||(e[1]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),t("select",ye,[...e[2]||(e[2]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512)]),e[6]||(e[6]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'
        })
        select.search('value')
      `),s(`
    `)],-1))])}const we=p(me,[["render",$e]]),Ve=u({name:"SetData",data(){return{setDataSingle:null,setDataMultiple:null}},mounted(){this.setDataSingle=new i({select:this.$refs.setDataSingle,events:{error:l=>{console.error(l)}}}),this.setDataMultiple=new i({select:this.$refs.setDataMultiple,events:{error:l=>{console.error(l)}}})},methods:{setData(){fetch("https://api.gofakeit.com/json",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:"array",rowcount:10,indent:!1,fields:[{name:"text",function:"generate",params:{str:"{firstname} {lastname}"}},{name:"selected",function:"bool"}]})}).then(l=>l.json()).then(l=>{this.setDataSingle.setData(l),this.setDataMultiple.setData(l)}).catch(l=>console.error(l))}}}),De={id:"setData",class:"content"},Oe={class:"alert info"},Me={class:"row"},ke={ref:"setDataSingle"},Ce={ref:"setDataMultiple",multiple:""};function Ee(l,e,c,v,g,h){const n=d("router-link");return a(),o("div",De,[e[3]||(e[3]=t("h2",{class:"header"},"setData",-1)),e[4]||(e[4]=t("p",null," The setData method allows you to dynamically update the options available in a SlimSelect instance by providing a new array of data objects. This is essential for creating responsive interfaces where the available options change based on user interactions, API responses, or other dynamic conditions. ",-1)),e[5]||(e[5]=t("p",null," When called, this method completely replaces the existing options and re-renders the SlimSelect interface, making it perfect for scenarios like dependent dropdowns, filtered lists, or any situation where the available choices need to be updated dynamically without recreating the entire component. ",-1)),e[6]||(e[6]=t("div",{class:"alert info"}," If you use a single select but an option is not selected it will select the first option. ",-1)),e[7]||(e[7]=t("div",{class:"alert info"}," If you use a single select but pass in data with multiple selected options, the first option will be selected. ",-1)),t("div",Oe,[e[2]||(e[2]=s(" To get a better break down of possible data options see ",-1)),r(n,{to:"/data#types"},{default:k(()=>[...e[1]||(e[1]=[s("data",-1)])]),_:1})]),t("div",Me,[t("div",{class:"btn",onClick:e[0]||(e[0]=(...f)=>l.setData&&l.setData(...f))},"Set Data"),t("select",ke,null,512),t("select",Ce,null,512)]),e[8]||(e[8]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'
        })

        // Array of objects
        select.setData([
          {text: 'Value 1', value: 'value1'},
          {text: 'Value 2', value: 'value2'},
          {
            label: 'Group 1',
            options: [
              {text: 'Value 3', value: 'value3'},
              {text: 'Value 4', value: 'value4'},
            ]
          }
        ])
      `),s(`
    `)],-1))])}const Te=p(Ve,[["render",Ee]]),Ke=u({name:"SetSelected",data(){return{selectedSingle:null,selectedMultiple:null,selectedKeepOrder:null}},mounted(){this.selectedSingle=new i({select:this.$refs.selectedSingle}),this.selectedMultiple=new i({select:this.$refs.selectedMultiple}),this.selectedKeepOrder=new i({select:this.$refs.selectedKeepOrder,settings:{keepOrder:!0}})},methods:{setSelected(){this.selectedSingle.open(),this.selectedSingle.setSelected("value2"),this.selectedMultiple.open(),this.selectedMultiple.setSelected(["value1","value3"]),this.selectedKeepOrder.open(),this.selectedKeepOrder.setSelected(["value3","value1"]),setTimeout(()=>{this.selectedSingle.close(),this.selectedMultiple.close(),this.selectedKeepOrder.close()},2e3)}}}),je={id:"setSelected",class:"content"},Ge={class:"row"},Ae={ref:"selectedSingle"},We={ref:"selectedMultiple",multiple:""},Ie={ref:"selectedKeepOrder",multiple:""};function Ne(l,e,c,v,g,h){return a(),o("div",je,[e[4]||(e[4]=t("h2",{class:"header"},"setSelected",-1)),e[5]||(e[5]=t("p",null," The setSelected method allows you to programmatically set the selected values in a SlimSelect instance. This is particularly useful for initializing selections, responding to external events, or implementing complex selection logic based on other application state. ",-1)),e[6]||(e[6]=t("p",null," The method accepts either a single string value or an array of strings, making it flexible for both single-select and multi-select scenarios. Additionally, you can control whether the afterChange event is triggered by providing a second boolean parameter, giving you fine-grained control over when selection events fire. ",-1)),t("div",Ge,[t("div",{class:"btn",onClick:e[0]||(e[0]=(...n)=>l.setSelected&&l.setSelected(...n))},"Set Selected"),t("select",Ae,[...e[1]||(e[1]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),t("select",We,[...e[2]||(e[2]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512),t("select",Ie,[...e[3]||(e[3]=[t("option",{value:"value1"},"Value 1",-1),t("option",{value:"value2"},"Value 2",-1),t("option",{value:"value3"},"Value 3",-1)])],512)]),e[7]||(e[7]=t("pre",null,[s("      "),t("code",{class:"language-javascript"},`
        var select = new SlimSelect({
          select: '#selectElement'

          // Optional - If you want to keep the order of the selected values
          // settings: { keepOrder: true }
        })
        select.setSelected('value1' /* or */ ['value1', 'value3'])
        console.log(select.getSelected())

        // To not trigger the afterChange callback
        select.setSelected('value1', false)
      `),s(`
    `)],-1))])}const Be=p(Ke,[["render",Ne]]),He=u({name:"Methods",components:{AdSlot:C,GetSelected:re,SetSelected:Be,GetData:Z,SetData:Te,EnableDisable:R,OpenClose:he,Search:we,Destroy:W}}),Le={id:"methods",class:"contents"};function Pe(l,e,c,v,g,h){const n=d("GetSelected"),f=d("SetSelected"),b=d("AdSlot"),$=d("GetData"),w=d("SetData"),V=d("EnableDisable"),D=d("OpenClose"),O=d("Search"),M=d("Destroy");return a(),o("div",Le,[r(n),r(f),r(b,{"ad-slot":"1270131515"}),r($),r(w),r(b,{"ad-slot":"1270131515"}),r(V),r(D),r(b,{"ad-slot":"1270131515"}),r(O),r(M)])}const ze=p(He,[["render",Pe]]);export{ze as default};
