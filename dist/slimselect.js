(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/pack.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/config.js":
/*!************************!*\
  !*** ./dist/config.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass config {\n    constructor(info) {\n        this.isMultiple = false;\n        this.id = '';\n        this.isAjax = false;\n        this.isSearching = false;\n        this.showSearch = true;\n        this.searchHighlight = false;\n        this.closeOnSelect = true;\n        this.showContent = 'auto'; // options: auto, up, down\n        this.searchPlaceholder = 'Search';\n        this.searchText = 'No Results';\n        this.placeholderText = 'Select Value';\n        this.allowDeselect = false;\n        this.isEnabled = true;\n        this.valuesUseText = false;\n        this.showOptionTooltips = false;\n        // Classes\n        this.main = 'ss-main';\n        this.singleSelected = 'ss-single-selected';\n        this.arrow = 'ss-arrow';\n        this.multiSelected = 'ss-multi-selected';\n        this.add = 'ss-add';\n        this.plus = 'ss-plus';\n        this.values = 'ss-values';\n        this.value = 'ss-value';\n        this.valueText = 'ss-value-text';\n        this.valueDelete = 'ss-value-delete';\n        this.content = 'ss-content';\n        this.open = 'ss-open';\n        this.openAbove = 'ss-open-above';\n        this.openBelow = 'ss-open-below';\n        this.search = 'ss-search';\n        this.searchHighlighter = 'ss-search-highlight';\n        this.addable = 'ss-addable';\n        this.list = 'ss-list';\n        this.optgroup = 'ss-optgroup';\n        this.optgroupLabel = 'ss-optgroup-label';\n        this.option = 'ss-option';\n        this.highlighted = 'ss-highlighted';\n        this.disabled = 'ss-disabled';\n        this.hide = 'ss-hide';\n        this.id = 'ss-' + Math.floor(Math.random() * 100000);\n        this.style = info.select.style.cssText;\n        this.class = info.select.classList;\n        this.isMultiple = info.select.multiple;\n        this.isAjax = info.isAjax;\n        this.showSearch = (info.showSearch === false ? false : true);\n        this.searchHighlight = (info.searchHighlight === true ? true : false);\n        this.closeOnSelect = (info.closeOnSelect === false ? false : true);\n        if (info.showContent) {\n            this.showContent = info.showContent;\n        }\n        this.isEnabled = (info.isEnabled === false ? false : true);\n        if (info.searchPlaceholder) {\n            this.searchPlaceholder = info.searchPlaceholder;\n        }\n        if (info.searchText) {\n            this.searchText = info.searchText;\n        }\n        if (info.placeholderText) {\n            this.placeholderText = info.placeholderText;\n        }\n        this.allowDeselect = (info.allowDeselect === true ? true : false);\n        if (info.valuesUseText) {\n            this.valuesUseText = info.valuesUseText;\n        }\n        if (info.showOptionTooltips) {\n            this.showOptionTooltips = info.showOptionTooltips;\n        }\n    }\n}\nexports.default = config;\n\n\n//# sourceURL=webpack:///./dist/config.js?");

/***/ }),

/***/ "./dist/data.js":
/*!**********************!*\
  !*** ./dist/data.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Class is responsible for managing the data\nclass data {\n    constructor(info) {\n        this.contentOpen = false;\n        this.contentPosition = 'below';\n        this.isOnChangeEnabled = true;\n        this.main = info.main;\n        this.searchValue = '';\n        this.data = [];\n        this.filtered = null;\n        this.parseSelectData();\n        this.setSelectedFromSelect();\n    }\n    // Take in a value loop through the data till you find it and return it\n    getObjectFromData(value, type = 'id') {\n        for (let i = 0; i < this.data.length; i++) {\n            // If option check if value is the same\n            if (type in this.data[i] && String(this.data[i][type]) === String(value)) {\n                return this.data[i];\n            }\n            // If optgroup loop through options\n            if (this.data[i].hasOwnProperty('options')) {\n                const optgroupObject = this.data[i];\n                for (let ii = 0; ii < optgroupObject.options.length; ii++) {\n                    if (String(optgroupObject.options[ii][type]) === String(value)) {\n                        return optgroupObject.options[ii];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    // From data get option | option[] of selected values\n    // If single select return last selected value\n    getSelected() {\n        let value = null;\n        const values = [];\n        for (let i = 0; i < this.data.length; i++) {\n            // Deal with optgroups\n            if (this.data[i].hasOwnProperty('label')) {\n                if (this.data[i].hasOwnProperty('options')) {\n                    const options = this.data[i].options;\n                    for (let o = 0; o < options.length; o++) {\n                        if (options[o].selected) {\n                            // If single return option\n                            if (!this.main.config.isMultiple) {\n                                value = options[o];\n                            }\n                            else {\n                                // Push to multiple array\n                                values.push(options[o]);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                // Push options to array\n                if (this.data[i].selected) {\n                    // If single return option\n                    if (!this.main.config.isMultiple) {\n                        value = this.data[i];\n                    }\n                    else {\n                        // Push to multiple array\n                        values.push(this.data[i]);\n                    }\n                }\n            }\n        }\n        // Either return array or object or null\n        if (this.main.config.isMultiple) {\n            return values;\n        }\n        return value;\n    }\n    // Remove object from selected\n    removeFromSelected(value, type = 'id') {\n        if (this.main.config.isMultiple) {\n            const values = [];\n            const selected = this.getSelected();\n            for (let i = 0; i < selected.length; i++) {\n                if (String(selected[i][type]) !== String(value)) {\n                    values.push(selected[i][type]);\n                }\n            }\n            this.setSelected(values, type);\n        }\n    }\n    // Trigger onChange callback\n    onDataChange() {\n        if (this.main.onChange && this.isOnChangeEnabled) {\n            this.main.onChange(JSON.parse(JSON.stringify(this.getSelected())));\n        }\n    }\n    newOption(info) {\n        return {\n            data: (info.data ? info.data : {}),\n            disabled: (info.disabled ? info.disabled : false),\n            display: (info.display ? info.display : true),\n            id: (info.id ? info.id : String(Math.floor(Math.random() * 100000000))),\n            innerHTML: (info.innerHTML ? info.innerHTML : ''),\n            placeholder: (info.placeholder ? info.placeholder : ''),\n            selected: (info.selected ? info.selected : false),\n            text: (info.text ? info.text : ''),\n            value: (info.value ? info.value : '')\n        };\n    }\n    // If select type is multiple append value and set selected\n    addToSelected(value, type = 'id') {\n        if (this.main.config.isMultiple) {\n            const values = [];\n            const selected = this.getSelected();\n            for (let i = 0; i < selected.length; i++) {\n                values.push(selected[i][type]);\n            }\n            values.push(value);\n            this.setSelected(values, type);\n        }\n    }\n    // From value set the selected value\n    setSelected(value, type = 'id') {\n        // Loop through data and set selected values\n        for (let i = 0; i < this.data.length; i++) {\n            // Deal with optgroups\n            if (this.data[i].hasOwnProperty('label')) {\n                if (this.data[i].hasOwnProperty('options')) {\n                    const options = this.data[i].options;\n                    for (let o = 0; o < options.length; o++) {\n                        options[o].selected = this.shouldBeSelected(options[o], value, type);\n                    }\n                }\n            }\n            else {\n                this.data[i].selected = this.shouldBeSelected(this.data[i], value, type);\n            }\n        }\n    }\n    // From passed in select element pull optgroup and options into data\n    parseSelectData() {\n        this.data = [];\n        // Loop through nodes and create data\n        const element = this.main.select.element;\n        const nodes = element.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n            if (nodes[i].nodeName === 'OPTGROUP') {\n                const node = nodes[i];\n                const optgp = {\n                    label: node.label,\n                    options: []\n                };\n                const options = nodes[i].childNodes;\n                for (let ii = 0; ii < options.length; ii++) {\n                    if (options[ii].nodeName === 'OPTION') {\n                        optgp.options.push(this.pullOptionData(options[ii]));\n                    }\n                }\n                this.data.push(optgp);\n            }\n            else if (nodes[i].nodeName === 'OPTION') {\n                this.data.push(this.pullOptionData(nodes[i]));\n            }\n        }\n    }\n    // From select element get current selected and set selected\n    setSelectedFromSelect() {\n        const options = this.main.select.element.options;\n        if (this.main.config.isMultiple) {\n            const newSelected = [];\n            for (let i = 0; i < options.length; i++) {\n                const opt = options[i];\n                if (opt.selected) {\n                    newSelected.push(this.getObjectFromData(opt.value, 'value').id);\n                }\n            }\n            this.setSelected(newSelected, 'id');\n        }\n        else {\n            // Single select element\n            if (options.selectedIndex !== -1) {\n                const opt = options[options.selectedIndex];\n                const value = opt.value;\n                this.setSelected(value, 'value');\n            }\n        }\n    }\n    // Add to the current data array\n    add(opt) {\n        const obj = {\n            data: {},\n            disabled: false,\n            display: true,\n            id: String(Math.floor(Math.random() * 100000000)),\n            innerHTML: '',\n            placeholder: '',\n            selected: false,\n            text: opt.text,\n            value: opt.value\n        };\n        this.data.push(obj);\n    }\n    // Take in search string and return filtered list of values\n    search(search) {\n        this.searchValue = search;\n        if (search.trim() === '') {\n            this.filtered = null;\n            return;\n        }\n        const valuesArray = this.data.slice(0);\n        search = search.trim().toLowerCase();\n        const filtered = valuesArray.map((obj) => {\n            // If optgroup\n            if (obj.hasOwnProperty('options')) {\n                const optgroupObj = obj;\n                const options = optgroupObj.options.filter((opt) => {\n                    return opt.text.toLowerCase().indexOf(search) !== -1;\n                });\n                if (options.length !== 0) {\n                    const optgp = Object.assign({}, optgroupObj); // Break pointer\n                    optgp.options = options;\n                    return optgp;\n                }\n            }\n            // If single option\n            if (obj.hasOwnProperty('text')) {\n                const optionObj = obj;\n                if (optionObj.text.toLowerCase().indexOf(search) !== -1) {\n                    return obj;\n                }\n            }\n            return null;\n        });\n        // Filter out false values\n        this.filtered = filtered.filter((info) => {\n            return info;\n        });\n    }\n    // From passed in option pull pieces of usable information\n    pullOptionData(opt) {\n        return {\n            data: opt.dataset,\n            disabled: opt.disabled,\n            id: (opt.dataset ? opt.dataset.id : false) || String(Math.floor(Math.random() * 100000000)),\n            innerHTML: opt.innerHTML,\n            placeholder: opt.dataset.placeholder || null,\n            selected: opt.selected,\n            text: opt.text,\n            value: opt.value\n        };\n    }\n    // Determines whether or not passed in option should be selected based upon possible values\n    shouldBeSelected(opt, value, type = 'id') {\n        if (Array.isArray(value)) {\n            for (let i = 0; i < value.length; i++) {\n                if (String(opt[type]) === String(value[i])) {\n                    return true;\n                }\n            }\n        }\n        else {\n            if (String(opt[type]) === String(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.default = data;\nfunction validateData(da) {\n    if (!da) {\n        console.error('Data must be an array of objects');\n        return;\n    }\n    let isValid = false;\n    let errorCount = 0;\n    for (let i = 0; i < da.length; i++) {\n        if (da[i].hasOwnProperty('label')) {\n            if (da[i].hasOwnProperty('options')) {\n                const optgp = da[i];\n                const options = optgp.options;\n                for (let j = 0; j < options.length; j++) {\n                    isValid = validateOption(options[j]);\n                    if (!isValid) {\n                        errorCount++;\n                    }\n                }\n            }\n        }\n        else {\n            const opt = da[i];\n            isValid = validateOption(opt);\n            if (!isValid) {\n                errorCount++;\n            }\n        }\n    }\n    return errorCount === 0;\n}\nexports.validateData = validateData;\nfunction validateOption(opt) {\n    if (opt.text === undefined) {\n        console.error('Data object option must have at least have a text value. Check object: ' + JSON.stringify(opt));\n        return false;\n    }\n    return true;\n}\nexports.validateOption = validateOption;\n\n\n//# sourceURL=webpack:///./dist/data.js?");

/***/ }),

/***/ "./dist/helper.js":
/*!************************!*\
  !*** ./dist/helper.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction hasClass(element, className) {\n    if (!(!className || !element || !element.classList || !element.classList.contains(className))) {\n        return element;\n    }\n    return null;\n}\nfunction parentByClass(childElement, className) {\n    if (!childElement || childElement === document) {\n        return null;\n    }\n    else if (hasClass(childElement, className)) {\n        return childElement;\n    }\n    else {\n        return parentByClass(childElement.parentNode, className);\n    }\n}\nfunction hasClassInTree(element, className) {\n    return hasClass(element, className) || parentByClass(element, className);\n}\nexports.hasClassInTree = hasClassInTree;\nfunction ensureElementInView(container, element) {\n    // Determine container top and bottom\n    const cTop = container.scrollTop + container.offsetTop; // Make sure to have offsetTop\n    const cBottom = cTop + container.clientHeight;\n    // Determine element top and bottom\n    const eTop = element.offsetTop;\n    const eBottom = eTop + element.clientHeight;\n    // Check if out of view\n    if (eTop < cTop) {\n        container.scrollTop -= (cTop - eTop);\n    }\n    else if (eBottom > cBottom) {\n        container.scrollTop += (eBottom - cBottom);\n    }\n}\nexports.ensureElementInView = ensureElementInView;\nfunction putContent(el, currentPosition, isOpen) {\n    const height = el.offsetHeight;\n    const rect = el.getBoundingClientRect();\n    const elemTop = (isOpen ? rect.top : rect.top - height);\n    const elemBottom = (isOpen ? rect.bottom : rect.bottom + height);\n    if (elemTop <= 0) {\n        return 'below';\n    }\n    if (elemBottom >= window.innerHeight) {\n        return 'above';\n    }\n    return (isOpen ? currentPosition : 'below');\n}\nexports.putContent = putContent;\nfunction debounce(func, wait = 100, immediate = false) {\n    let timeout;\n    return function (...args) {\n        const context = this;\n        const later = () => {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\nexports.debounce = debounce;\nfunction isValueInArrayOfObjects(selected, key, value) {\n    if (!Array.isArray(selected)) {\n        return selected[key] === value;\n    }\n    else {\n        for (let i = 0; i < selected.length; i++) {\n            if (selected[i] && selected[i][key] && selected[i][key] === value) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.isValueInArrayOfObjects = isValueInArrayOfObjects;\nfunction highlight(text, search, className) {\n    const pattern = new RegExp('(>[^<.]*)(' + search.trim() + ')([^<.]*)', 'gi');\n    const replaceWith = '$1<span ' + (className ? 'class=\"' + className + '\"' : '') + '\">$2</span>$3';\n    return text.replace(pattern, replaceWith);\n}\nexports.highlight = highlight;\n\n\n//# sourceURL=webpack:///./dist/helper.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = __webpack_require__(/*! ./config */ \"./dist/config.js\");\nconst data_1 = __webpack_require__(/*! ./data */ \"./dist/data.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"./dist/helper.js\");\nconst select_1 = __webpack_require__(/*! ./select */ \"./dist/select.js\");\nconst slim_1 = __webpack_require__(/*! ./slim */ \"./dist/slim.js\");\nclass SlimSelect {\n    constructor(info) {\n        this.ajax = null;\n        this.addable = null;\n        this.beforeOnChange = null;\n        this.onChange = null;\n        this.beforeOpen = null;\n        this.afterOpen = null;\n        this.beforeClose = null;\n        this.afterClose = null;\n        this.validate(info);\n        const selectElement = (typeof info.select === 'string' ? document.querySelector(info.select) : info.select);\n        // If select already has a slim select id on it lets destroy it first\n        if (selectElement.dataset.ssid) {\n            this.destroy(selectElement.dataset.ssid);\n        }\n        // Set ajax function if passed in\n        if (info.ajax) {\n            this.ajax = info.ajax;\n        }\n        // Add addable if option is passed in\n        if (info.addable) {\n            this.addable = info.addable;\n        }\n        this.config = new config_1.default({\n            allowDeselect: info.allowDeselect,\n            closeOnSelect: info.closeOnSelect,\n            isAjax: (info.ajax ? true : false),\n            isEnabled: info.isEnabled,\n            placeholderText: info.placeholder,\n            searchHighlight: info.searchHighlight,\n            searchPlaceholder: info.searchPlaceholder,\n            searchText: info.searchText,\n            select: selectElement,\n            showContent: info.showContent,\n            showOptionTooltips: info.showOptionTooltips,\n            showSearch: info.showSearch,\n            valuesUseText: info.valuesUseText\n        });\n        this.select = new select_1.default({\n            main: this,\n            select: selectElement\n        });\n        this.data = new data_1.default({ main: this });\n        this.slim = new slim_1.default({ main: this });\n        // Add after original select element\n        this.select.element.parentNode.insertBefore(this.slim.container, this.select.element.nextSibling);\n        // If data is passed in lets set it\n        // and thus will start the render\n        if (info.data) {\n            this.setData(info.data);\n        }\n        else {\n            // Do an initial render on startup\n            this.render();\n        }\n        // Add onclick listener to document to closeContent if clicked outside\n        document.addEventListener('click', (e) => {\n            if (!helper_1.hasClassInTree(e.target, this.config.id)) {\n                this.close();\n            }\n        });\n        window.addEventListener('scroll', helper_1.debounce((e) => {\n            if (this.data.contentOpen && this.config.showContent === 'auto') {\n                if (helper_1.putContent(this.slim.content, this.data.contentPosition, this.data.contentOpen) === 'above') {\n                    this.moveContentAbove();\n                }\n                else {\n                    this.moveContentBelow();\n                }\n            }\n        }), false);\n        // Add event callbacks after everthing has been created\n        if (info.beforeOnChange) {\n            this.beforeOnChange = info.beforeOnChange;\n        }\n        if (info.onChange) {\n            this.onChange = info.onChange;\n        }\n        if (info.beforeOpen) {\n            this.beforeOpen = info.beforeOpen;\n        }\n        if (info.afterOpen) {\n            this.afterOpen = info.afterOpen;\n        }\n        if (info.beforeClose) {\n            this.beforeClose = info.beforeClose;\n        }\n        if (info.afterClose) {\n            this.afterClose = info.afterClose;\n        }\n    }\n    validate(info) {\n        const select = (typeof info.select === 'string' ? document.querySelector(info.select) : info.select);\n        if (!select) {\n            throw new Error('Could not find select element');\n        }\n        if (select.tagName !== 'SELECT') {\n            throw new Error('Element isnt of type select');\n        }\n    }\n    selected() {\n        if (this.config.isMultiple) {\n            const selected = this.data.getSelected();\n            const outputSelected = [];\n            for (let i = 0; i < selected.length; i++) {\n                outputSelected.push(selected[i].value);\n            }\n            return outputSelected;\n        }\n        else {\n            const selected = this.data.getSelected();\n            return (selected ? selected.value : '');\n        }\n    }\n    // Sets value of the select, adds it to data and original select\n    set(value, type = 'value', close = true, render = true) {\n        if (this.config.isMultiple && !Array.isArray(value)) {\n            this.data.addToSelected(value, type);\n        }\n        else {\n            this.data.setSelected(value, type);\n        }\n        this.select.setValue();\n        this.data.onDataChange(); // Trigger on change callback\n        this.render();\n        if (close) {\n            this.close();\n        }\n    }\n    // setSelected is just mapped to the set method\n    setSelected(value, type = 'value', close = true, render = true) {\n        this.set(value, type, close, render);\n    }\n    setData(data) {\n        // Validate data if passed in\n        const isValid = data_1.validateData(data);\n        if (!isValid) {\n            console.error('Validation problem on: #' + this.select.element.id);\n            return;\n        } // If data passed in is not valid DO NOT parse, set and render\n        const newData = JSON.parse(JSON.stringify(data));\n        const selected = this.data.getSelected();\n        // If its an ajax type keep selected values\n        if (this.config.isAjax && selected) {\n            if (this.config.isMultiple) {\n                const reverseSelected = selected.reverse();\n                for (let i = 0; i < reverseSelected.length; i++) {\n                    newData.unshift(reverseSelected[i]);\n                }\n            }\n            else {\n                newData.unshift(this.data.getSelected());\n                newData.unshift({\n                    placeholder: true,\n                    text: ''\n                });\n            }\n        }\n        this.select.create(newData);\n        this.data.parseSelectData();\n        this.data.setSelectedFromSelect();\n    }\n    // addData will append to the current data set\n    addData(data) {\n        // Validate data if passed in\n        const isValid = data_1.validateData([data]);\n        if (!isValid) {\n            console.error('Validation problem on: #' + this.select.element.id);\n            return;\n        } // If data passed in is not valid DO NOT parse, set and render\n        const opt = this.data.newOption(data);\n        this.data.add(opt);\n        this.select.create(this.data.data);\n        this.data.parseSelectData();\n        this.data.setSelectedFromSelect();\n        this.render();\n    }\n    // Open content section\n    open() {\n        // Dont open if disabled\n        if (!this.config.isEnabled) {\n            return;\n        }\n        // Dont do anything if the content is already open\n        if (this.data.contentOpen) {\n            return;\n        }\n        // Focus on input field\n        this.slim.search.input.focus();\n        // Run beforeOpen callback\n        if (this.beforeOpen) {\n            this.beforeOpen();\n        }\n        if (this.config.isMultiple) {\n            this.slim.multiSelected.plus.classList.add('ss-cross');\n        }\n        else {\n            this.slim.singleSelected.arrowIcon.arrow.classList.remove('arrow-down');\n            this.slim.singleSelected.arrowIcon.arrow.classList.add('arrow-up');\n        }\n        this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.add((this.data.contentPosition === 'above' ? this.config.openAbove : this.config.openBelow));\n        this.slim.content.classList.add(this.config.open);\n        // Check showContent to see if they want to specifically show in a certain direction\n        if (this.config.showContent.toLowerCase() === 'up') {\n            this.moveContentAbove();\n        }\n        else if (this.config.showContent.toLowerCase() === 'down') {\n            this.moveContentBelow();\n        }\n        else {\n            // Auto identify where to put it\n            if (helper_1.putContent(this.slim.content, this.data.contentPosition, this.data.contentOpen) === 'above') {\n                this.moveContentAbove();\n            }\n            else {\n                this.moveContentBelow();\n            }\n        }\n        // Move to selected option for single option\n        if (!this.config.isMultiple) {\n            const selected = this.data.getSelected();\n            if (selected) {\n                const selectedId = selected.id;\n                const selectedOption = this.slim.list.querySelector('[data-id=\"' + selectedId + '\"]');\n                if (selectedOption) {\n                    helper_1.ensureElementInView(this.slim.list, selectedOption);\n                }\n            }\n        }\n        // setTimeout is for animation completion\n        setTimeout(() => {\n            this.data.contentOpen = true;\n            // Run afterOpen callback\n            if (this.afterOpen) {\n                this.afterOpen();\n            }\n        }, 300);\n    }\n    // Close content section\n    close() {\n        // Dont do anything if the content is already closed\n        if (!this.data.contentOpen) {\n            return;\n        }\n        // Run beforeClose calback\n        if (this.beforeClose) {\n            this.beforeClose();\n        }\n        // this.slim.search.input.blur() // Removed due to safari quirk\n        if (this.config.isMultiple) {\n            this.slim.multiSelected.container.classList.remove(this.config.openAbove);\n            this.slim.multiSelected.container.classList.remove(this.config.openBelow);\n            this.slim.multiSelected.plus.classList.remove('ss-cross');\n        }\n        else {\n            this.slim.singleSelected.container.classList.remove(this.config.openAbove);\n            this.slim.singleSelected.container.classList.remove(this.config.openBelow);\n            this.slim.singleSelected.arrowIcon.arrow.classList.add('arrow-down');\n            this.slim.singleSelected.arrowIcon.arrow.classList.remove('arrow-up');\n        }\n        this.slim.content.classList.remove(this.config.open);\n        this.data.contentOpen = false;\n        this.search(''); // Clear search\n        // Reset the content below\n        setTimeout(() => {\n            this.slim.content.removeAttribute('style');\n            this.data.contentPosition = 'below';\n            this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.remove(this.config.openAbove);\n            this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.remove(this.config.openBelow);\n            // After content is closed lets blur on the input field\n            this.slim.search.input.blur();\n            // Run afterClose callback\n            if (this.afterClose) {\n                this.afterClose();\n            }\n        }, 300);\n    }\n    moveContentAbove() {\n        const selectHeight = (this.config.isMultiple ? this.slim.multiSelected.container.offsetHeight : this.slim.singleSelected.container.offsetHeight);\n        const contentHeight = this.slim.content.offsetHeight;\n        const height = selectHeight + contentHeight - 1;\n        this.slim.content.style.margin = '-' + height + 'px 0 0 0';\n        this.slim.content.style.height = (height - selectHeight + 1) + 'px';\n        this.slim.content.style.transformOrigin = 'center bottom';\n        this.data.contentPosition = 'above';\n        this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.remove(this.config.openBelow);\n        this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.add(this.config.openAbove);\n    }\n    moveContentBelow() {\n        this.slim.content.removeAttribute('style');\n        this.data.contentPosition = 'below';\n        this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.remove(this.config.openAbove);\n        this.slim[(this.config.isMultiple ? 'multiSelected' : 'singleSelected')].container.classList.add(this.config.openBelow);\n    }\n    // Set to enabled, remove disabled classes and removed disabled from original select\n    enable() {\n        this.config.isEnabled = true;\n        if (this.config.isMultiple) {\n            this.slim.multiSelected.container.classList.remove(this.config.disabled);\n        }\n        else {\n            this.slim.singleSelected.container.classList.remove(this.config.disabled);\n        }\n        // Disable original select but dont trigger observer\n        this.select.disconnectMutationObserver();\n        this.select.element.disabled = false;\n        this.slim.search.input.disabled = false;\n        this.select.observeMutationObserver();\n    }\n    // Set to disabled, add disabled classes and add disabled to original select\n    disable() {\n        this.config.isEnabled = false;\n        if (this.config.isMultiple) {\n            this.slim.multiSelected.container.classList.add(this.config.disabled);\n        }\n        else {\n            this.slim.singleSelected.container.classList.add(this.config.disabled);\n        }\n        // Enable original select but dont trigger observer\n        this.select.disconnectMutationObserver();\n        this.select.element.disabled = true;\n        this.slim.search.input.disabled = true;\n        this.select.observeMutationObserver();\n    }\n    // Take in string value and search current options\n    search(value) {\n        // Only filter data and rerender if value has changed\n        if (this.data.searchValue !== value) {\n            this.slim.search.input.value = value;\n            if (this.config.isAjax) {\n                if (value.trim() === '') {\n                    this.setData([]);\n                    this.data.search('');\n                    this.render();\n                }\n                else {\n                    const master = this;\n                    this.config.isSearching = true;\n                    this.render();\n                    this.ajax(value, (info) => {\n                        // Only process if return callback is not false\n                        master.config.isSearching = false;\n                        if (Array.isArray(info)) {\n                            info.unshift({ text: '', placeholder: true });\n                            master.setData(info);\n                            master.data.search(value);\n                            master.render();\n                        }\n                        else if (typeof info === 'string') {\n                            master.slim.options(info);\n                        }\n                        else {\n                            master.render();\n                        }\n                    });\n                }\n            }\n            else {\n                this.data.search(value);\n                this.render();\n            }\n        }\n    }\n    setSearchText(text) {\n        this.config.searchText = text;\n    }\n    render() {\n        if (this.config.isMultiple) {\n            this.slim.values();\n        }\n        else {\n            this.slim.placeholder();\n            this.slim.deselect();\n        }\n        this.slim.options();\n    }\n    // Display original select again and remove slim\n    destroy(id = null) {\n        const slim = (id ? document.querySelector('.' + id) : this.slim.container);\n        const select = (id ? document.querySelector(`[data-ssid=${id}]`) : this.select.element);\n        // If there is no slim dont do anything\n        if (!slim || !select) {\n            return;\n        }\n        // Show original select\n        select.style.display = null;\n        delete select.dataset.ssid;\n        // Remove slim from original select dropdown\n        this.select.element.slim = null;\n        // Remove slim select\n        if (slim.parentElement) {\n            slim.parentElement.removeChild(slim);\n        }\n    }\n}\nexports.SlimSelect = SlimSelect;\nexports.default = SlimSelect;\n\n\n//# sourceURL=webpack:///./dist/index.js?");

/***/ }),

/***/ "./dist/pack.js":
/*!**********************!*\
  !*** ./dist/pack.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n__webpack_require__(/*! custom-event-polyfill */ \"./node_modules/_custom-event-polyfill@0.3.0@custom-event-polyfill/custom-event-polyfill.js\"); // Needed for IE to use custom events\nconst index_1 = __webpack_require__(/*! ./index */ \"./dist/index.js\");\nmodule.exports = index_1.default;\n\n\n//# sourceURL=webpack:///./dist/pack.js?");

/***/ }),

/***/ "./dist/select.js":
/*!************************!*\
  !*** ./dist/select.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass select {\n    constructor(info) {\n        this.element = info.select;\n        this.main = info.main;\n        // If original select is set to disabled lets make sure slim is too\n        if (this.element.disabled) {\n            this.main.config.isEnabled = false;\n        }\n        this.addAttributes();\n        this.addEventListeners();\n        this.addMutationObserver();\n        // Add slim to original select dropdown\n        this.element.slim = info.main;\n    }\n    setValue() {\n        if (!this.main.data.getSelected()) {\n            return;\n        }\n        if (this.main.config.isMultiple) {\n            // If multiple loop through options and set selected\n            const selected = this.main.data.getSelected();\n            const options = this.element.options;\n            for (let o = 0; o < options.length; o++) {\n                const opt = options[o];\n                opt.selected = false;\n                for (let s = 0; s < selected.length; s++) {\n                    if (selected[s].value === opt.value) {\n                        opt.selected = true;\n                    }\n                }\n            }\n        }\n        else {\n            // If single select simply set value\n            const selected = this.main.data.getSelected();\n            this.element.value = (selected ? selected.value : '');\n        }\n        // Do not trigger onChange callbacks for this event listener\n        this.main.data.isOnChangeEnabled = false;\n        this.element.dispatchEvent(new CustomEvent('change'));\n        this.main.data.isOnChangeEnabled = true;\n    }\n    addAttributes() {\n        this.element.tabIndex = -1;\n        this.element.style.display = 'none';\n        // Add slim select id\n        this.element.dataset.ssid = this.main.config.id;\n    }\n    // Add onChange listener to original select\n    addEventListeners() {\n        this.element.addEventListener('change', (e) => {\n            this.main.data.setSelectedFromSelect();\n            this.main.render();\n        });\n    }\n    // Add MutationObserver to select\n    addMutationObserver() {\n        // Only add if not in ajax mode\n        if (this.main.config.isAjax) {\n            return;\n        }\n        this.mutationObserver = new MutationObserver((mutations) => {\n            this.main.data.parseSelectData();\n            this.main.data.setSelectedFromSelect();\n            this.main.render();\n        });\n        this.observeMutationObserver();\n    }\n    observeMutationObserver() {\n        this.mutationObserver.observe(this.element, {\n            attributes: true,\n            characterData: true,\n            childList: true\n        });\n    }\n    disconnectMutationObserver() {\n        if (this.mutationObserver) {\n            this.mutationObserver.disconnect();\n        }\n    }\n    // Create select element and optgroup/options\n    create(data) {\n        // Clear out select\n        this.element.innerHTML = '';\n        for (let i = 0; i < data.length; i++) {\n            if (data[i].hasOwnProperty('options')) {\n                const optgroupObject = data[i];\n                const optgp = document.createElement('optgroup');\n                optgp.label = optgroupObject.label;\n                for (let o = 0; o < optgroupObject.options.length; o++) {\n                    optgp.appendChild(this.createOption(optgroupObject.options[o]));\n                }\n                this.element.appendChild(optgp);\n            }\n            else {\n                this.element.appendChild(this.createOption(data[i]));\n            }\n        }\n    }\n    createOption(info) {\n        const opt = document.createElement('option');\n        opt.value = info.value || info.text;\n        opt.innerHTML = info.innerHTML || info.text;\n        if (info.selected) {\n            opt.selected = info.selected;\n        }\n        if (info.disabled) {\n            opt.disabled = true;\n        }\n        if (info.placeholder) {\n            opt.setAttribute('data-placeholder', 'true');\n        }\n        if (info.data && typeof info.data === 'object') {\n            Object.keys(info.data).forEach((key) => {\n                opt.setAttribute('data-' + key, info.data[key]);\n            });\n        }\n        return opt;\n    }\n}\nexports.default = select;\n\n\n//# sourceURL=webpack:///./dist/select.js?");

/***/ }),

/***/ "./dist/slim.js":
/*!**********************!*\
  !*** ./dist/slim.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst data_1 = __webpack_require__(/*! ./data */ \"./dist/data.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"./dist/helper.js\");\n// Class is responsible for creating all the elements\nclass slim {\n    constructor(info) {\n        this.main = info.main;\n        // Create elements in order of appending\n        this.container = this.containerDiv();\n        this.content = this.contentDiv();\n        this.search = this.searchDiv();\n        this.list = this.listDiv();\n        this.options();\n        if (this.main.config.isMultiple) {\n            this.multiSelected = this.multiSelectedDiv();\n            this.container.appendChild(this.multiSelected.container);\n        }\n        else {\n            this.singleSelected = this.singleSelectedDiv();\n            this.container.appendChild(this.singleSelected.container);\n        }\n        this.container.appendChild(this.content);\n        this.content.appendChild(this.search.container);\n        this.content.appendChild(this.list);\n    }\n    // Loop through data || filtered data and build options and append to list container\n    options(content = '') {\n        const data = this.main.data.filtered || this.main.data.data;\n        // Clear out innerHtml\n        this.list.innerHTML = '';\n        // If content is being passed just use that text\n        if (content !== '') {\n            const searching = document.createElement('div');\n            searching.classList.add(this.main.config.option);\n            searching.classList.add(this.main.config.disabled);\n            searching.innerHTML = content;\n            this.list.appendChild(searching);\n            return;\n        }\n        // If ajax and isSearching\n        if (this.main.config.isAjax && this.main.config.isSearching) {\n            const searching = document.createElement('div');\n            searching.classList.add(this.main.config.option);\n            searching.classList.add(this.main.config.disabled);\n            searching.innerHTML = 'Searching...';\n            this.list.appendChild(searching);\n            return;\n        }\n        // If no results show no results text\n        if (data.length === 0) {\n            const noResults = document.createElement('div');\n            noResults.classList.add(this.main.config.option);\n            noResults.classList.add(this.main.config.disabled);\n            noResults.innerHTML = this.main.config.searchText;\n            this.list.appendChild(noResults);\n            return;\n        }\n        // Append individual options to div container\n        for (let i = 0; i < data.length; i++) {\n            // Create optgroup\n            if (data[i].hasOwnProperty('label')) {\n                const item = data[i];\n                const optgp = document.createElement('div');\n                optgp.classList.add(this.main.config.optgroup);\n                // Create label\n                const optgroupLabel = document.createElement('div');\n                optgroupLabel.classList.add(this.main.config.optgroupLabel);\n                optgroupLabel.innerHTML = item.label;\n                optgp.appendChild(optgroupLabel);\n                const options = item.options;\n                for (let ii = 0; ii < options.length; ii++) {\n                    optgp.appendChild(this.option(options[ii]));\n                }\n                this.list.appendChild(optgp);\n            }\n            else {\n                this.list.appendChild(this.option(data[i]));\n            }\n        }\n    }\n    // Get selected values and append to multiSelected values container\n    // and remove those who shouldnt exist\n    values() {\n        if (!this.main.config.isMultiple) {\n            return;\n        }\n        let currentNodes = this.multiSelected.values.childNodes;\n        const selected = this.main.data.getSelected();\n        // Remove nodes that shouldnt be there\n        let exists = false;\n        const nodesToRemove = [];\n        for (let c = 0; c < currentNodes.length; c++) {\n            exists = true;\n            const node = currentNodes[c];\n            for (let s = 0; s < selected.length; s++) {\n                if (String(selected[s].id) === String(node.dataset.id)) {\n                    exists = false;\n                }\n            }\n            if (exists) {\n                nodesToRemove.push(node);\n            }\n        }\n        for (let i = 0; i < nodesToRemove.length; i++) {\n            nodesToRemove[i].classList.add('ss-out');\n            this.multiSelected.values.removeChild(nodesToRemove[i]);\n        }\n        // Add values that dont currently exist\n        currentNodes = this.multiSelected.values.childNodes;\n        for (let s = 0; s < selected.length; s++) {\n            exists = false;\n            for (let c = 0; c < currentNodes.length; c++) {\n                const node = currentNodes[c];\n                if (String(selected[s].id) === String(node.dataset.id)) {\n                    exists = true;\n                }\n            }\n            if (!exists) {\n                if (currentNodes.length === 0) {\n                    this.multiSelected.values.appendChild(this.valueDiv(selected[s]));\n                }\n                else if (s === 0) {\n                    this.multiSelected.values.insertBefore(this.valueDiv(selected[s]), currentNodes[s]);\n                }\n                else {\n                    currentNodes[s - 1].insertAdjacentElement('afterend', this.valueDiv(selected[s]));\n                }\n            }\n        }\n        // If there are no values set placeholder\n        if (selected.length === 0) {\n            const placeholder = document.createElement('span');\n            placeholder.classList.add(this.main.config.disabled);\n            placeholder.innerHTML = this.main.config.placeholderText;\n            this.multiSelected.values.innerHTML = placeholder.outerHTML;\n        }\n    }\n    // Based upon current selection set placeholder text\n    placeholder() {\n        const selected = this.main.data.getSelected();\n        // Placeholder display\n        if (selected === null || (selected && selected.placeholder)) {\n            const placeholder = document.createElement('span');\n            placeholder.classList.add(this.main.config.disabled);\n            placeholder.innerHTML = this.main.config.placeholderText;\n            this.singleSelected.placeholder.innerHTML = placeholder.outerHTML;\n        }\n        else {\n            let selectedValue = '';\n            if (selected) {\n                selectedValue = selected.innerHTML && this.main.config.valuesUseText !== true ? selected.innerHTML : selected.text;\n            }\n            this.singleSelected.placeholder.innerHTML = (selected ? selectedValue : '');\n        }\n    }\n    // Based upon current selection/settings hide/show deselect\n    deselect() {\n        // if allowDeselect is false just hide it\n        if (!this.main.config.allowDeselect) {\n            this.singleSelected.deselect.classList.add('ss-hide');\n            return;\n        }\n        if (this.main.selected() === '') {\n            this.singleSelected.deselect.classList.add('ss-hide');\n        }\n        else {\n            this.singleSelected.deselect.classList.remove('ss-hide');\n        }\n    }\n    // Create main container\n    containerDiv() {\n        // Create main container\n        const container = document.createElement('div');\n        container.classList.add(this.main.config.id);\n        container.classList.add(this.main.config.main);\n        // Add style and classes\n        container.style.cssText = this.main.config.style;\n        for (let i = 0; i < this.main.config.class.length; i++) {\n            container.classList.add(this.main.config.class[i]);\n        }\n        return container;\n    }\n    singleSelectedDiv() {\n        const container = document.createElement('div');\n        container.classList.add(this.main.config.singleSelected);\n        // Placeholder text\n        const placeholder = document.createElement('span');\n        placeholder.classList.add('placeholder');\n        container.appendChild(placeholder);\n        // Deselect\n        let deselect = null;\n        deselect = document.createElement('span');\n        deselect.innerHTML = 'X';\n        deselect.classList.add('ss-deselect');\n        deselect.onclick = (e) => {\n            this.main.set('');\n            e.stopPropagation();\n        };\n        container.appendChild(deselect);\n        // Arrow\n        const arrowContainer = document.createElement('span');\n        arrowContainer.classList.add(this.main.config.arrow);\n        const arrowIcon = document.createElement('span');\n        arrowIcon.classList.add('arrow-down');\n        arrowContainer.appendChild(arrowIcon);\n        container.appendChild(arrowContainer);\n        // Add onclick for main selector div\n        container.onclick = () => {\n            if (!this.main.config.isEnabled) {\n                return;\n            }\n            this.main.data.contentOpen ? this.main.close() : this.main.open();\n        };\n        return {\n            arrowIcon: {\n                arrow: arrowIcon,\n                container: arrowContainer\n            },\n            container,\n            deselect,\n            placeholder\n        };\n    }\n    multiSelectedDiv() {\n        const container = document.createElement('div');\n        container.classList.add(this.main.config.multiSelected);\n        const values = document.createElement('div');\n        values.classList.add(this.main.config.values);\n        container.appendChild(values);\n        const add = document.createElement('div');\n        add.classList.add(this.main.config.add);\n        const plus = document.createElement('span');\n        plus.classList.add(this.main.config.plus);\n        plus.onclick = (e) => {\n            if (this.main.data.contentOpen) {\n                this.main.close();\n                e.stopPropagation();\n            }\n        };\n        add.appendChild(plus);\n        container.appendChild(add);\n        container.onclick = (e) => {\n            if (!this.main.config.isEnabled) {\n                return;\n            }\n            // Open only if you are not clicking on x text\n            const target = e.target;\n            if (!target.classList.contains(this.main.config.valueDelete)) {\n                this.main.open();\n            }\n        };\n        return {\n            add,\n            container,\n            plus,\n            values\n        };\n    }\n    valueDiv(opt) {\n        const value = document.createElement('div');\n        value.classList.add(this.main.config.value);\n        value.dataset.id = opt.id;\n        const text = document.createElement('span');\n        text.classList.add(this.main.config.valueText);\n        text.innerHTML = (opt.innerHTML && this.main.config.valuesUseText !== true ? opt.innerHTML : opt.text);\n        value.appendChild(text);\n        const deleteSpan = document.createElement('span');\n        deleteSpan.classList.add(this.main.config.valueDelete);\n        deleteSpan.innerHTML = 'x';\n        deleteSpan.onclick = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (!this.main.config.isEnabled) {\n                return;\n            }\n            if (this.main.beforeOnChange) {\n                const selected = this.main.data.getSelected();\n                const currentValues = JSON.parse(JSON.stringify(selected));\n                // Remove from current selection\n                for (let i = 0; i < currentValues.length; i++) {\n                    if (currentValues[i].id === opt.id) {\n                        currentValues.splice(i, 1);\n                    }\n                }\n                const beforeOnchange = this.main.beforeOnChange(currentValues);\n                if (beforeOnchange !== false) {\n                    this.main.data.removeFromSelected(opt.id, 'id');\n                    this.main.render();\n                    this.main.select.setValue();\n                }\n            }\n            else {\n                this.main.data.removeFromSelected(opt.id, 'id');\n                this.main.render();\n                this.main.select.setValue();\n                this.main.data.onDataChange(); // Trigger on change callback\n            }\n        };\n        value.appendChild(deleteSpan);\n        return value;\n    }\n    // Create content container\n    contentDiv() {\n        const container = document.createElement('div');\n        container.classList.add(this.main.config.content);\n        return container;\n    }\n    searchDiv() {\n        const container = document.createElement('div');\n        const input = document.createElement('input');\n        container.classList.add(this.main.config.search);\n        // We still want the search to be tabable but not shown\n        if (!this.main.config.showSearch) {\n            container.classList.add(this.main.config.hide);\n            input.readOnly = true;\n        }\n        input.type = 'search';\n        input.placeholder = this.main.config.searchPlaceholder;\n        input.tabIndex = 0;\n        input.onclick = (e) => {\n            setTimeout(() => {\n                const target = e.target;\n                if (target.value === '') {\n                    this.main.search('');\n                }\n            }, 10);\n        };\n        input.onkeydown = (e) => {\n            if (e.key === 'ArrowUp') {\n                this.main.open();\n                this.highlightUp();\n                e.preventDefault();\n            }\n            else if (e.key === 'ArrowDown') {\n                this.main.open();\n                this.highlightDown();\n                e.preventDefault();\n            }\n            else if (e.key === 'Tab') {\n                this.main.close();\n            }\n            else if (e.key === 'Enter') {\n                e.preventDefault();\n            }\n        };\n        input.onkeyup = (e) => {\n            const target = e.target;\n            if (e.key === 'Enter') {\n                if (this.main.addable && e.ctrlKey) {\n                    addable.click();\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return;\n                }\n                const highlighted = this.list.querySelector('.' + this.main.config.highlighted);\n                if (highlighted) {\n                    highlighted.click();\n                }\n            }\n            else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                // Cancel out to leave for onkeydown to handle\n            }\n            else if (e.key === 'Escape') {\n                this.main.close();\n            }\n            else {\n                if (this.main.config.showSearch && this.main.data.contentOpen) {\n                    this.main.search(target.value);\n                }\n                else {\n                    input.value = '';\n                }\n            }\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        input.onfocus = () => { this.main.open(); };\n        container.appendChild(input);\n        let addable;\n        if (this.main.addable) {\n            addable = document.createElement('div');\n            addable.classList.add(this.main.config.addable);\n            addable.innerHTML = '+';\n            addable.onclick = (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n                const inputValue = this.search.input.value;\n                if (inputValue.trim() === '') {\n                    this.search.input.focus();\n                    return;\n                }\n                const addableValue = this.main.addable(inputValue);\n                let addableValueStr = '';\n                if (!addableValue) {\n                    return;\n                }\n                if (typeof addableValue === 'object') {\n                    const validValue = data_1.validateOption(addableValue);\n                    if (validValue) {\n                        this.main.addData(addableValue);\n                        addableValueStr = (addableValue.value ? addableValue.value : addableValue.text);\n                    }\n                }\n                else {\n                    this.main.addData(this.main.data.newOption({\n                        text: addableValue,\n                        value: addableValue\n                    }));\n                    addableValueStr = addableValue;\n                }\n                this.main.search('');\n                setTimeout(() => {\n                    this.main.set(addableValueStr, 'value', false, false);\n                }, 100);\n                // Close it only if closeOnSelect = true\n                if (this.main.config.closeOnSelect) {\n                    setTimeout(() => {\n                        this.main.close();\n                    }, 100);\n                }\n            };\n            container.appendChild(addable);\n        }\n        return {\n            addable,\n            container,\n            input\n        };\n    }\n    highlightUp() {\n        const highlighted = this.list.querySelector('.' + this.main.config.highlighted);\n        let prev = null;\n        if (highlighted) {\n            prev = highlighted.previousSibling;\n            while (prev !== null) {\n                if (prev.classList.contains(this.main.config.disabled)) {\n                    prev = prev.previousSibling;\n                    continue;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            const allOptions = this.list.querySelectorAll('.' + this.main.config.option + ':not(.' + this.main.config.disabled + ')');\n            prev = allOptions[allOptions.length - 1];\n        }\n        // Do not select if optgroup label\n        if (prev && prev.classList.contains(this.main.config.optgroupLabel)) {\n            prev = null;\n        }\n        // Check if parent is optgroup\n        if (prev === null) {\n            const parent = highlighted.parentNode;\n            if (parent.classList.contains(this.main.config.optgroup)) {\n                if (parent.previousSibling) {\n                    const prevNodes = parent.previousSibling.querySelectorAll('.' + this.main.config.option + ':not(.' + this.main.config.disabled + ')');\n                    if (prevNodes.length) {\n                        prev = prevNodes[prevNodes.length - 1];\n                    }\n                }\n            }\n        }\n        // If previous element exists highlight it\n        if (prev) {\n            if (highlighted) {\n                highlighted.classList.remove(this.main.config.highlighted);\n            }\n            prev.classList.add(this.main.config.highlighted);\n            helper_1.ensureElementInView(this.list, prev);\n        }\n    }\n    highlightDown() {\n        const highlighted = this.list.querySelector('.' + this.main.config.highlighted);\n        let next = null;\n        if (highlighted) {\n            next = highlighted.nextSibling;\n            while (next !== null) {\n                if (next.classList.contains(this.main.config.disabled)) {\n                    next = next.nextSibling;\n                    continue;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            next = this.list.querySelector('.' + this.main.config.option + ':not(.' + this.main.config.disabled + ')');\n        }\n        // Check if parent is optgroup\n        if (next === null && highlighted !== null) {\n            const parent = highlighted.parentNode;\n            if (parent.classList.contains(this.main.config.optgroup)) {\n                if (parent.nextSibling) {\n                    const sibling = parent.nextSibling;\n                    next = sibling.querySelector('.' + this.main.config.option + ':not(.' + this.main.config.disabled + ')');\n                }\n            }\n        }\n        // If previous element exists highlight it\n        if (next) {\n            if (highlighted) {\n                highlighted.classList.remove(this.main.config.highlighted);\n            }\n            next.classList.add(this.main.config.highlighted);\n            helper_1.ensureElementInView(this.list, next);\n        }\n    }\n    // Create main container that options will reside\n    listDiv() {\n        const list = document.createElement('div');\n        list.classList.add(this.main.config.list);\n        list.onmousewheel = (e) => {\n            const scrollTop = list.scrollTop;\n            const scrollHeight = list.scrollHeight;\n            const height = list.offsetHeight;\n            const delta = (e.type === 'DOMMouseScroll' ? e.detail * -40 : e.wheelDelta);\n            const up = delta > 0;\n            const prevent = () => {\n                e.stopPropagation();\n                e.preventDefault();\n                e.returnValue = false;\n                return false;\n            };\n            if (!up && -delta > scrollHeight - height - scrollTop) {\n                // Scrolling down, but this will take us past the bottom.\n                list.scrollTop = scrollHeight;\n                return prevent();\n            }\n            else if (up && delta > scrollTop) {\n                // Scrolling up, but this will take us past the top.\n                list.scrollTop = 0;\n                return prevent();\n            }\n        };\n        return list;\n    }\n    // Create single option\n    option(data) {\n        // Add hidden placeholder\n        if (data.placeholder) {\n            const placeholder = document.createElement('div');\n            placeholder.classList.add(this.main.config.option);\n            placeholder.classList.add(this.main.config.hide);\n            return placeholder;\n        }\n        const opt = document.createElement('div');\n        opt.classList.add(this.main.config.option);\n        const selected = this.main.data.getSelected();\n        opt.dataset.id = data.id;\n        if (this.main.config.searchHighlight && this.main.slim && this.main.slim.search.input.value.trim() !== '') {\n            opt.innerHTML = helper_1.highlight(data.innerHTML, this.main.slim.search.input.value, this.main.config.searchHighlighter);\n        }\n        else {\n            opt.innerHTML = data.innerHTML;\n        }\n        if (this.main.config.showOptionTooltips) {\n            opt.setAttribute('title', opt.textContent);\n        }\n        const master = this;\n        opt.onclick = function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            const element = this;\n            const elementID = element.dataset.id;\n            if (master.main.beforeOnChange) {\n                let value;\n                const objectInfo = JSON.parse(JSON.stringify(master.main.data.getObjectFromData(elementID)));\n                objectInfo.selected = true;\n                if (master.main.config.isMultiple) {\n                    value = JSON.parse(JSON.stringify(selected));\n                    value.push(objectInfo);\n                }\n                else {\n                    value = JSON.parse(JSON.stringify(objectInfo));\n                }\n                const beforeOnchange = master.main.beforeOnChange(value);\n                if (beforeOnchange !== false) {\n                    master.main.set(elementID, 'id', master.main.config.closeOnSelect);\n                }\n            }\n            else {\n                master.main.set(elementID, 'id', master.main.config.closeOnSelect);\n            }\n        };\n        if (data.disabled || (selected && helper_1.isValueInArrayOfObjects(selected, 'id', data.id))) {\n            opt.onclick = null;\n            opt.classList.add(this.main.config.disabled);\n        }\n        return opt;\n    }\n}\nexports.default = slim;\n\n\n//# sourceURL=webpack:///./dist/slim.js?");

/***/ }),

/***/ "./node_modules/_custom-event-polyfill@0.3.0@custom-event-polyfill/custom-event-polyfill.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/_custom-event-polyfill@0.3.0@custom-event-polyfill/custom-event-polyfill.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Polyfill for creating CustomEvents on IE9/10/11\n\n// code pulled from:\n// https://github.com/d4tocchini/customevent-polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\ntry {\n    var ce = new window.CustomEvent('test');\n    ce.preventDefault();\n    if (ce.defaultPrevented !== true) {\n        // IE has problems with .preventDefault() on custom events\n        // http://stackoverflow.com/questions/23349191\n        throw new Error('Could not prevent default');\n    }\n} catch(e) {\n  var CustomEvent = function(event, params) {\n    var evt, origPrevent;\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n\n    evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    origPrevent = evt.preventDefault;\n    evt.preventDefault = function () {\n      origPrevent.call(this);\n      try {\n        Object.defineProperty(this, 'defaultPrevented', {\n          get: function () {\n            return true;\n          }\n        });\n      } catch(e) {\n        this.defaultPrevented = true;\n      }\n    };\n    return evt;\n  };\n\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent; // expose definition to window\n}\n\n\n//# sourceURL=webpack:///./node_modules/_custom-event-polyfill@0.3.0@custom-event-polyfill/custom-event-polyfill.js?");

/***/ })

/******/ });
});